#!/usr/bin/env bash

set -euo pipefail

readonly GTK_IMPORT_LINE='@import "colors.css";'
readonly GTK_CSS_FILES=(
  "$HOME/.config/gtk-4.0/gtk.css"
  "$HOME/.config/gtk-4.0/gtk-dark.css"
)
readonly SERVICES_TO_RESTART=(
  "xdg-desktop-portal-gtk"
)
readonly HYPRLOCK_PNG="$HOME/.config/hypr/hyprlock/icon.png"
readonly HYPRLOCK_SVG="$HOME/.cache/wal/icon.svg"

# Concurrency/debounce helpers
readonly CACHE_DIR="$HOME/.cache/walset"
readonly STATE_FILE="$CACHE_DIR/walset.last"
readonly PIDFILE="$CACHE_DIR/walset.pid"

declare -A FOLDER_COLORS=(
  ["blue"]="#89B4FA" ["grey"]="#878688" ["green"]="#84A756" ["adwaita"]="#B4BEFE"
  ["carmine"]="#AC0406" ["magenta"]="#CBA6F7" ["orange"]="#E58E3B" ["pink"]="#F5C2E7"
  ["red"]="#F38BA8" ["breeze"]="#89DCEB" ["teal"]="#94E2D5" ["yellow"]="#F9E2AF"
  ["violet"]="#7653B4" ["cyan"]="#04ADC4" ["nordic"]="#7895B3" ["palebrown"]="#D1BFAE"
  ["deeporange"]="#DB633A" ["brown"]="#AD8B6C" ["paleorange"]="#E8C289" ["darkcyan"]="#45ABB7"
  ["black"]="#4F4F4F" ["bluegrey"]="#607D8B"
)

log_error() {
  echo "Error: $*" >&2
}

log_info() {
  echo "Info: $*"
}

# Usage/help
print_usage() {
  echo "Description: Apply a new colorscheme and update the system theme."
  echo "Usage: $(basename "$0") <path_to_wallpaper> [--scheme <matugen_scheme>] [--mode <dark|light>]"
  echo ""
  echo "Options:"
  echo "  -s, --scheme   Matugen scheme type (default: scheme-tonal-spot)"
  echo "  -m, --mode     Theme mode: dark|light (default: dark)"
  echo "  -h, --help     Show this help and exit"
  echo ""
  echo "Examples:"
  echo "  $(basename "$0") ~/Pictures/wallpaper.jpg"
  echo "  $(basename "$0") ~/Pictures/wallpaper.jpg --mode light"
  echo "  $(basename "$0") ~/Pictures/wallpaper.jpg --scheme scheme-tonal-spot --mode dark"
}

# Cleanup child jobs and pidfile on exit or termination
cleanup() {
  local ec=$?
  # Kill background jobs spawned by this shell
  local jpids
  jpids=$(jobs -p 2>/dev/null || true)
  if [[ -n "$jpids" ]]; then
    kill -TERM "$jpids" 2>/dev/null || true
    sleep 0.2
    kill -KILL "$jpids" 2>/dev/null || true
  fi
  # Remove pidfile only if we still own it
  if [[ -f "$PIDFILE" ]] && [[ "$(cat "$PIDFILE" 2>/dev/null)" == "$$" ]]; then
    rm -f "$PIDFILE" 2>/dev/null || true
  fi
  return $ec
}

# Kill any previously running walset instance and its children
preempt_previous() {
  [[ -f "$PIDFILE" ]] || return 0
  local oldpid
  oldpid=$(cat "$PIDFILE" 2>/dev/null || true)
  [[ -n "$oldpid" ]] || return 0
  if [[ "$oldpid" != "$$" ]] && kill -0 "$oldpid" 2>/dev/null; then
    log_info "Preempting previous walset (PID $oldpid)"
    # Try graceful termination: children first, then parent
    pkill -TERM -P "$oldpid" 2>/dev/null || true
    kill -TERM "$oldpid" 2>/dev/null || true
    # Wait briefly, then escalate if needed
    for _ in 1 2 3; do
      if kill -0 "$oldpid" 2>/dev/null; then
        sleep 0.2
      else
        break
      fi
    done
    if kill -0 "$oldpid" 2>/dev/null; then
      pkill -KILL -P "$oldpid" 2>/dev/null || true
      kill -KILL "$oldpid" 2>/dev/null || true
    fi
  fi
}

# Optimized system agents update
update_system_agents() {
  local pids=()

  for service in "${SERVICES_TO_RESTART[@]}"; do
    if systemctl --user is-active --quiet "$service" 2>/dev/null; then
      systemctl --user restart "$service" &>/dev/null &
      pids+=($!)
    fi
  done


  pkill -f "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1" &>/dev/null || true
  /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 &>/dev/null &

  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done
}

# Optimized GTK CSS update
update_gtk_css() {
  local file
  for file in "${GTK_CSS_FILES[@]}"; do
    if [[ -L "$file" ]] || ! grep -Fxq "$GTK_IMPORT_LINE" "$file" 2>/dev/null; then
      mkdir -p "$(dirname "$file")"
      echo "$GTK_IMPORT_LINE" > "${file}.tmp" && mv "${file}.tmp" "$file"
    fi
  done
}

update_spotify() {
  if ! command -v spicetify &>/dev/null; then
    return 0
  fi

  if ! pgrep -x spotify &>/dev/null; then
    return 0
  fi

  if [[ "$(spicetify config current_theme 2>/dev/null)" != "marketplace" ]]; then
    spicetify config current_theme marketplace &>/dev/null || {
      log_error "Failed to set spicetify theme"
      return 1
    }
  fi

  {
    timeout 10s spicetify -q watch -s &
    local watch_pid=$!
    sleep 2
    kill "$watch_pid" 2>/dev/null || true
  } &>/dev/null &
}

update_folder_colors() {
  if ! command -v papirus-folders &>/dev/null; then
    log_info "papirus-folders not found, skipping folder theming"
    return 0
  fi

  local cache_file="$HOME/.cache/wal/papirus-folders.txt"
  if [[ ! -f "$cache_file" ]]; then
    log_error "Color cache file not found: $cache_file"
    return 1
  fi

  local target_hex
  target_hex=$(<"$cache_file") || {
    log_error "Failed to read color from cache file"
    return 1
  }

  # Clean up the hex color (remove # if present and ensure uppercase)
  target_hex="${target_hex#\#}"
  target_hex="${target_hex^^}"

  if [[ ! "$target_hex" =~ ^[0-9A-F]{6}$ ]]; then
    log_error "Invalid hex color format in cache file: $target_hex"
    return 1
  fi

  local -i r1 g1 b1
  r1=$(( 0x${target_hex:0:2} ))
  g1=$(( 0x${target_hex:2:2} ))
  b1=$(( 0x${target_hex:4:2} ))

  # Find closest color using optimized distance calculation
  local min_distance=1000000 closest_color=""
  local name color_hex r2 g2 b2 distance

  for name in "${!FOLDER_COLORS[@]}"; do
    color_hex="${FOLDER_COLORS[$name]#\#}"
    r2=$(( 0x${color_hex:0:2} ))
    g2=$(( 0x${color_hex:2:2} ))
    b2=$(( 0x${color_hex:4:2} ))

    distance=$(( (r1-r2)*(r1-r2) + (g1-g2)*(g1-g2) + (b1-b2)*(b1-b2) ))

    if (( distance < min_distance )); then
      min_distance=$distance
      closest_color=$name
    fi
  done

  if [[ -n "$closest_color" ]]; then

    papirus-folders -C "$closest_color" -t Papirus-Dark &>/dev/null || {
      log_error "Failed to apply folder color: $closest_color"
      return 1
    }
  else
    log_error "No matching folder color found"
    return 1
  fi
}

validate_input() {
  local wallpaper="$1"

  if [[ ! -f "$wallpaper" ]]; then
    log_error "Wallpaper file not found: $wallpaper"
    exit 1
  fi

  # Check if it's an image file
  if ! file "$wallpaper" | grep -qE "(image|bitmap)" 2>/dev/null; then
    log_error "File is not a valid image: $wallpaper"
    exit 1
  fi
}

reload_terminal() {
  local pids=()

  if command -v fish &>/dev/null; then
    {
      fish -c "yes | fish_config theme save Matugen" 2>/dev/null
      [[ -f "$HOME/.cache/wal/fzf.fish" ]] && fish "$HOME/.cache/wal/fzf.fish" 2>/dev/null
    } &
    pids+=($!)
  fi

  if command -v kitty &>/dev/null; then
    kitty +kitten themes --reload-in=all matugen &>/dev/null &
    pids+=($!)
  fi

  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done
}

main() {

  # Defaults
  local MATUGEN_SCHEME="scheme-tonal-spot"
  local MODE="dark"
  local wallpaper=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        print_usage; exit 0 ;;
      -s|--scheme)
        [[ $# -ge 2 ]] || { log_error "Missing value for $1"; exit 1; }
        MATUGEN_SCHEME="$2"; shift 2 ;;
      -m|--mode)
        [[ $# -ge 2 ]] || { log_error "Missing value for $1"; exit 1; }
        MODE="$2"; shift 2 ;;
      --)
        shift; break ;;
      -*)
        # Unknown flag from external caller; skip it and its value if present
        if [[ $# -ge 2 && "$2" != -* ]]; then shift 2; else shift; fi ;;
      *)
        if [[ -z "$wallpaper" ]]; then
          wallpaper="$1"; shift
        else
          log_error "Unexpected positional argument: '$1'. Use --scheme or --mode flags."
          exit 1
        fi ;;
    esac
  done

  if [[ -z "$wallpaper" ]]; then
    print_usage
    exit 1
  fi

  # Sanity: constrain MODE to dark|light
  if [[ "$MODE" != "dark" && "$MODE" != "light" ]]; then
    MODE="dark"
  fi

  [[ -d "$CACHE_DIR" ]] || mkdir -p "$CACHE_DIR" || {
    log_error "Failed to create cache directory: $CACHE_DIR"
    exit 1
  }

  # Preempt any previous run, then register our PID and set traps for clean termination
  preempt_previous
  echo "$$" > "$PIDFILE" 2>/dev/null || true
  trap cleanup EXIT
  trap 'exit 130' INT
  trap 'exit 143' TERM

  local pids=()

  validate_input "$wallpaper"

  log_info "Applying wallpaper and updating theme: $wallpaper"

  # Skip if identical to last applied
  if [[ -f "$STATE_FILE" ]]; then
    readarray -t __last < "$STATE_FILE" 2>/dev/null || true
    if [[ "${__last[0]:-}" == "$wallpaper" && "${__last[1]:-}" == "$MATUGEN_SCHEME" && "${__last[2]:-}" == "$MODE" ]]; then
      log_info "No changes since last apply; skipping."
      exit 0
    fi
  fi

  if ! matugen image --type "$MATUGEN_SCHEME" --mode "$MODE" "$wallpaper"; then
    log_error "Failed to generate color scheme with matugen"
    exit 1
  fi

  if ! wallust -q -s run "$wallpaper" -p "${MODE}16"; then
    log_error "Failed to process wallpaper with wallust"
    exit 1
  fi

  reload_terminal &
  pids+=($!)

  if pgrep -x nvim &>/dev/null; then
    killall -SIGUSR1 nvim 2>/dev/null || true
  fi

  if [[ -f "$HYPRLOCK_SVG" ]]; then
    if command -v magick &>/dev/null; then
      magick -background none "$HYPRLOCK_SVG" "$HYPRLOCK_PNG" &>/dev/null &
      pids+=($!)
    else
      log_error "ImageMagick not found, skipping hyprlock icon generation"
    fi
  fi


  update_system_agents &
  pids+=($!)

  update_gtk_css &
  pids+=($!)

  if command -v bat &>/dev/null; then
    bat cache --build &>/dev/null &
    pids+=($!)
  fi

  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Slow updates in background - but wait for them to prevent orphaned processes
  local bg_pids=()

  update_folder_colors &
  bg_pids+=($!)

  update_spotify &
  bg_pids+=($!)

  # Wait for background processes to complete to prevent hanging
  for pid in "${bg_pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Record last applied state
  printf "%s\n%s\n%s\n" "$wallpaper" "$MATUGEN_SCHEME" "$MODE" > "$STATE_FILE" 2>/dev/null || true

  log_info "Theme application completed successfully"
}


main "$@"
