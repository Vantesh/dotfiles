#!/usr/bin/env bash
# dmsctl - System control interface with DMS backend support
#
# Provides a consistent interface for brightness, audio, media, and session
# controls. Prefers the DMS quickshell backend when available and falls back
# to standard utilities otherwise.
#
# Environment Variables:
#   DMSCTL_INCREMENT - Default brightness/volume step (default: 5)
#   DMSCTL_GAMMA - Default night mode temperature (default: 4500)
#   DMSCTL_EDITOR_APP_CLASS - Editor app class for logout handling (default: "code")
#   NO_COLOR - Disables colored output when set
#
# Exit codes:
#   0 (success), 1 (failure), 2 (invalid args), 127 (missing dependency)

set -euo pipefail

shopt -s nullglob globstar

readonly PROG_NAME="${0##*/}"
readonly DEFAULT_INCREMENT="${DMSCTL_INCREMENT:-5}"
readonly DEFAULT_GAMMA="${DMSCTL_GAMMA:-4500}"
readonly EDITOR_APP_CLASS="${DMSCTL_EDITOR_APP_CLASS:-code}"

readonly EXIT_USAGE=2

USE_DMS=0

if [[ -t 2 && -z "${NO_COLOR:-}" ]]; then
  readonly COLOR_RESET=$'\033[0m'
  readonly COLOR_RED=$'\033[1;31m'
  readonly COLOR_GREEN=$'\033[1;32m'
  readonly COLOR_YELLOW=$'\033[1;33m'
else
  readonly COLOR_RESET=''
  readonly COLOR_RED=''
  readonly COLOR_GREEN=''
  readonly COLOR_YELLOW=''
fi

# Color variables are readonly, no need to reset in trap

# log outputs formatted log messages to stderr
# Arguments: $1 - level (INFO|WARN|ERROR), $2 - message
# Returns: 0 on success, 1 on error
log() {
  local level="${1:-}"
  local message="${2:-}"

  if [[ -z "$level" ]] || [[ -z "$message" ]]; then
    printf '%bERROR:%b log() requires a level and a message\n' "$COLOR_RED" "$COLOR_RESET" >&2
    return 1
  fi

  local color="$COLOR_RESET"
  case "${level^^}" in
  INFO) color="$COLOR_GREEN" ;;
  WARN) color="$COLOR_YELLOW" ;;
  ERROR) color="$COLOR_RED" ;;
  *)
    printf '%bERROR:%b Invalid log level: %s\n' "$COLOR_RED" "$COLOR_RESET" "$level" >&2
    return 1
    ;;
  esac

  printf '%b%s:%b %s\n' "$color" "${level^^}" "$COLOR_RESET" "$message" >&2
}

# die logs an error and exits with specified code
# Arguments: $1 - exit code, $2 - error message
# Returns: exits with specified code
die() {
  local code="${1:-1}"
  local message="${2:-Unexpected failure}"

  log ERROR "$message"
  exit "$code"
}

# usage_error logs an error, prints usage, and exits with EXIT_USAGE
# Arguments: $1 - error message (optional)
# Returns: exits with EXIT_USAGE code
usage_error() {
  local message="${1:-Invalid usage}"

  log ERROR "$message"
  print_usage >&2
  exit "$EXIT_USAGE"
}

# print_usage displays the command usage information
# Outputs: usage information to stdout
# Returns: 0
print_usage() {
  cat <<EOF
Usage:
  ${PROG_NAME} <command> [args]

Commands:
  brightness +/- [amount]    Adjust backlight step (default: ${DEFAULT_INCREMENT})
  volume +/- [amount]        Raise or lower output volume (default: ${DEFAULT_INCREMENT})
  volume mute|micmute        Toggle sinks and sources
  media next|prev|play-pause Control active media player
  lock                       Lock the current session
  logout                     Terminate the user session safely
  notepad                    Toggle the DMS notepad (requires DMS)
  night [temp]               Toggle night-light mode (default temp: ${DEFAULT_GAMMA})
EOF
}

# initialize_backend detects if DMS quickshell backend is available
# Returns: 0 on success, sets USE_DMS=1 if available
initialize_backend() {
  if command -v qs >/dev/null 2>&1 && qs list --all 2>/dev/null | grep -q '/quickshell/dms/'; then
    USE_DMS=1
  fi
}

# toggle_audio_channel toggles mute state for audio channel
# Arguments: $1 - mode (mute|micmute), $2 - wpctl target
# Returns: command exit status
toggle_audio_channel() {
  local mode="$1"
  local target="$2"
  local cmd=()

  if ((USE_DMS)); then
    log INFO "Toggled ${mode} via DMS"
    cmd=(qs -c dms ipc call audio "$mode")
  else
    if ! command -v wpctl >/dev/null 2>&1; then
      die 127 "Required command 'wpctl' is not available"
    fi
    log INFO "Toggled ${mode} via wpctl"
    cmd=(wpctl set-mute "$target" toggle)
  fi

  "${cmd[@]}"
}

# cmd_brightness adjusts screen brightness
# Arguments: $1 - sign (+|-), $2 - amount (optional, default: DEFAULT_INCREMENT)
# Returns: 0 on success
cmd_brightness() {
  local sign="${1:-}"

  if [[ "$sign" != "+" && "$sign" != "-" ]]; then
    usage_error "Brightness requires '+' or '-'"
  fi

  shift

  local amount="${1:-$DEFAULT_INCREMENT}"
  [[ "$amount" =~ ^[0-9]+$ ]] || usage_error "Brightness amount must be a non-negative integer"

  local method="decrement"
  [[ "$sign" == "+" ]] && method="increment"

  local backend=""
  local details=""
  local cmd=()

  if ((USE_DMS)); then
    backend="DMS"
    details="${method} by ${amount}"
    cmd=(qs -c dms ipc call brightness "$method" "$amount" "")
  else
    if ! command -v brightnessctl >/dev/null 2>&1; then
      die 127 "Required command 'brightnessctl' is not available"
    fi
    backend="brightnessctl"
    details="${amount}%${sign}"
    cmd=(brightnessctl set "${amount}%${sign}")
  fi

  "${cmd[@]}"
  log INFO "Adjusted brightness via ${backend} (${details})"
}

# cmd_volume adjusts or mutes audio volume
# Arguments: $1 - action (+|-|mute|micmute), $2 - amount for +/- (optional)
# Returns: 0 on success
cmd_volume() {
  local action="${1:-}"

  if [[ -z "$action" ]]; then
    usage_error "Volume requires an action"
  fi

  shift

  case "$action" in
  + | -)
    local amount="${1:-$DEFAULT_INCREMENT}"
    [[ "$amount" =~ ^[0-9]+$ ]] || usage_error "Volume amount must be a non-negative integer"

    local method="decrement"
    [[ "$action" == "+" ]] && method="increment"

    local backend=""
    local details=""
    local cmd=()

    if ((USE_DMS)); then
      backend="DMS"
      details="${method} by ${amount}"
      cmd=(qs -c dms ipc call audio "$method" "$amount")
    else
      if ! command -v wpctl >/dev/null 2>&1; then
        die 127 "Required command 'wpctl' is not available"
      fi
      backend="wpctl"
      details="${amount}%${action}"
      cmd=(wpctl set-volume -l 1 @DEFAULT_AUDIO_SINK@ "${amount}%${action}")
    fi

    "${cmd[@]}"
    log INFO "Adjusted volume via ${backend} (${details})"
    ;;
  mute)
    toggle_audio_channel mute @DEFAULT_AUDIO_SINK@
    ;;
  micmute)
    toggle_audio_channel micmute @DEFAULT_AUDIO_SOURCE@
    ;;
  *)
    usage_error "Invalid volume action '$action'"
    ;;
  esac
}

# cmd_media controls media playback
# Arguments: $1 - action (next|prev|play-pause)
# Returns: 0 on success
cmd_media() {
  local action="${1:-}"

  if [[ -z "$action" ]]; then
    usage_error "Media requires an action"
  fi

  shift

  local description=""
  local dms_action=""
  local playerctl_action=""

  case "$action" in
  next)
    description="Skipped to next track"
    dms_action="next"
    playerctl_action="next"
    ;;
  prev)
    description="Returned to previous track"
    dms_action="previous"
    playerctl_action="previous"
    ;;
  play-pause)
    description="Toggled media playback"
    dms_action="playPause"
    playerctl_action="play-pause"
    ;;
  *)
    usage_error "Invalid media action '$action'"
    ;;
  esac

  if ((USE_DMS)); then
    qs -c dms ipc call mpris "$dms_action"
    log INFO "${description} via DMS"
  else
    if ! command -v playerctl >/dev/null 2>&1; then
      die 127 "Required command 'playerctl' is not available"
    fi
    playerctl "$playerctl_action"
    log INFO "${description} via playerctl"
  fi
}

# cmd_lock locks the current session
# Returns: 0 on success
cmd_lock() {
  [[ $# -eq 0 ]] || usage_error "'lock' takes no arguments"

  if ((USE_DMS)); then
    qs -c dms ipc call lock lock
  else
    pidof hyprlock || uwsm-exec hyprlock --no-fade-in
  fi
}

# cmd_logout terminates the user session
# Returns: exits with loginctl status
cmd_logout() {
  [[ $# -eq 0 ]] || usage_error "'logout' takes no arguments"

  local user_name="${USER:-}"

  if [[ -z "$user_name" ]]; then
    die 1 "USER environment variable is not set"
  fi

  if [[ -n "$EDITOR_APP_CLASS" ]]; then
    local editor_pid=""

    case "${XDG_CURRENT_DESKTOP:-}" in
    Hyprland)
      if ! command -v jq >/dev/null 2>&1; then
        die 127 "Required command 'jq' is not available"
      fi
      editor_pid=$(hyprctl clients -j | jq -r --arg app "$EDITOR_APP_CLASS" '.[] | select(.class==$app) | .pid' | head -n1 || true)
      ;;
    niri)
      if ! command -v jq >/dev/null 2>&1; then
        die 127 "Required command 'jq' is not available"
      fi
      editor_pid=$(niri msg --json windows | jq -r --arg app "$EDITOR_APP_CLASS" '.[] | select(.app_id==$app) | .pid' | head -n1 || true)
      ;;
    *)
      log WARN "Unsupported desktop for editor shutdown: ${XDG_CURRENT_DESKTOP:-unknown}"
      ;;
    esac

    if [[ -n "$editor_pid" && "$editor_pid" != "null" ]]; then
      log INFO "Sent SIGKILL to ${EDITOR_APP_CLASS} (PID: ${editor_pid})"
      kill -9 "$editor_pid" 2>/dev/null
    fi
  fi

  log INFO "Requested logout via loginctl for ${user_name}"
  exec loginctl terminate-user "$user_name"
}

# cmd_notepad toggles DMS notepad
# Returns: 0 on success
cmd_notepad() {
  [[ $# -eq 0 ]] || usage_error "'notepad' takes no arguments"

  if ((USE_DMS)); then
    qs -c dms ipc call notepad toggle
    log INFO "Toggled DMS notepad"
  else
    log INFO "Skipped notepad toggle; DMS backend not detected"
  fi
}

# cmd_night toggles night mode with optional temperature
# Arguments: $1 - temperature (optional, default: DEFAULT_GAMMA)
# Returns: 0 on success
cmd_night() {
  local temp="${1:-$DEFAULT_GAMMA}"
  [[ "$temp" =~ ^[0-9]+$ ]] || usage_error "Night mode temperature must be a non-negative integer"

  if ((temp < 1000 || temp > 25000)); then
    die "$EXIT_USAGE" "Night mode temperature must be between 1000 and 25000"
  fi

  [[ $# -le 1 ]] || usage_error "'night' takes at most one argument (temperature)"

  if ((USE_DMS)); then
    qs -c dms ipc call night toggle
    log INFO "Toggled night mode via DMS"
  else
    if pgrep -x gammastep >/dev/null; then
      pkill -x gammastep
      log INFO "Disabled night mode via gammastep"
    else
      gammastep -O "$temp" &
      log INFO "Enabled night mode via gammastep (${temp}K)"
    fi
  fi
}

# dispatch routes subcommand to appropriate handler
# Arguments: $1 - subcommand, $@ - subcommand arguments
# Returns: subcommand exit status
dispatch() {
  local subcommand="${1,,}"
  shift

  case "$subcommand" in
  brightness) cmd_brightness "$@" ;;
  volume) cmd_volume "$@" ;;
  media) cmd_media "$@" ;;
  lock) cmd_lock "$@" ;;
  logout) cmd_logout "$@" ;;
  notepad) cmd_notepad "$@" ;;
  night) cmd_night "$@" ;;
  *)
    usage_error "Unknown subcommand '$subcommand'"
    ;;
  esac
}

main() {
  if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    print_usage
    exit 0
  fi

  if [[ $# -eq 0 ]]; then
    print_usage >&2
    exit "$EXIT_USAGE"
  fi

  if [[ "$(id -u)" -eq 0 ]]; then
    die "$EXIT_USAGE" "Do not run ${PROG_NAME} as root"
  fi

  initialize_backend
  dispatch "$@"
}

main "$@"
