#!/usr/bin/env bash
# --- Color Variables ---

readonly COLOR_RED='\e[31m'
readonly COLOR_GREEN='\e[32m'
readonly COLOR_YELLOW='\e[33m'
readonly COLOR_MAGENTA='\e[35m'
readonly COLOR_CYAN='\e[36m'
readonly STYLE_BOLD='\e[1m'
readonly COLOR_RESET='\e[0m'

#==============================================================================
# Logging Functions
#==============================================================================

print_step() {
  echo -e "\n${COLOR_MAGENTA}${STYLE_BOLD}==>${COLOR_RESET} ${COLOR_CYAN}$1${COLOR_RESET}\n"
}
print_info() {
  printf "${COLOR_GREEN}INFO:${COLOR_RESET} %b\n" "$1"
}
print_warning() {
  printf "${COLOR_YELLOW}WARNING:${COLOR_RESET} %b\n" "$1"
}
print_error() {
  printf "${COLOR_RED}ERROR:${COLOR_RESET} %b\n" "$1"
  exit 1
}
print_box() {
  figlet -t -f "$1" "$2"
}

confirm() {
  gum confirm --no-show-help --default=true "$1"
}

spinner() {
  local pid=$1
  local pkg="$2"

  gum spin --spinner line --title "Installing $pkg" -- sh -c "while kill -0 $pid 2>/dev/null; do sleep 0.1; done"
}

ask_for_sudo() {
  sudo -n true 2>/dev/null || {
    print_info "This script requires sudo privileges\n"
    sudo -v
  }
  while true; do
    sudo -n true
    sleep 60
    kill -0 "$$" || exit
  done 2>/dev/null &
}

# =============================================================================
# FILE MANIPULATION FUNCTIONS
# =============================================================================

write_system_config() {
  local config_file="$1"
  local description="$2"

  if sudo mkdir -p "$(dirname "$config_file")" && sudo tee "$config_file" >/dev/null; then
    sudo chmod 644 "$config_file" || print_error "Failed to set permissions for $config_file"
    print_info "$description written successfully"
  else
    print_error "Failed to write to $config_file"
  fi
}

create_backup() {
  local target_path="$1"
  local backup_path
  backup_path="${target_path}.bak.$(date +%Y%m%d%H%M%S)"

  if [ -e "$target_path" ]; then
    local backup_dir
    backup_dir=$(dirname "$backup_path")

    local copy_cmd=(cp)
    # Use sudo if destination dir is not writable
    if [ ! -w "$backup_dir" ]; then
      copy_cmd=(sudo cp)
    fi

    if [ -d "$target_path" ]; then
      if "${copy_cmd[@]}" -a "$target_path" "$backup_path"; then
        return 0
      else
        return 1
      fi
    else
      if "${copy_cmd[@]}" -a "$target_path" "$backup_path"; then
        return 0
      else
        return 1
      fi
    fi
  else
    print_warning "Path $target_path does not exist, skipping backup."
  fi
}

update_config() {
  local config_file="$1"
  local key="$2"
  local value="$3"

  if [[ ! -f "$config_file" ]]; then
    sudo touch "$config_file" &&
      if sudo chown root:root "$config_file"; then
        sudo chmod 644 "$config_file" || {
          print_error "Failed to create $config_file"
        }
      else
        print_error "Failed to set ownership for $config_file"
      fi
  fi

  local escaped_key
  escaped_key=$(printf '%s' "$key" | sed 's/\[/\\[/g; s/\]/\\]/g')
  # Regex to match lines like: [spaces][#][spaces]key[spaces]=
  local key_regex="^[[:space:]]*#*[[:space:]]*${escaped_key}[[:space:]]*="
  if sudo grep -qE "$key_regex" "$config_file"; then
    # Preserve existing spacing around '=' when updating
    # Capture spaces before and after '=' and reuse them in replacement
    if sudo sed -i -E "s|^[[:space:]]*#*[[:space:]]*${escaped_key}([[:space:]]*)=([[:space:]]*).*|${key}\\1=\\2${value}|" "$config_file"; then
      return 0
    else
      print_error "Failed to update $key in $config_file"
    fi
  else
    # Decide append style based on predominant style in file
    local style="compact"
    if sudo grep -qE '^[[:space:]]*[^#;][^=[:space:]]+[[:space:]]+=[[:space:]]+' "$config_file"; then
      style="spaced"
    fi

    if [[ "$style" == "spaced" ]]; then
      if echo -e "\n${key} = ${value}" | sudo tee -a "$config_file" >/dev/null; then
        return 0
      else
        print_error "Failed to append $key to $config_file"
      fi
    else
      if echo -e "\n${key}=${value}" | sudo tee -a "$config_file" >/dev/null; then
        return 0
      else
        print_error "Failed to append $key to $config_file"
      fi
    fi
  fi
}

# =============================================================================
# AUR HELPER INSTALLATION
# =============================================================================

has_package() {
  local pkg="$1"
  if pacman -Qq "$pkg" 2>/dev/null | grep -qx "$pkg"; then
    return 0
  else
    return 1
  fi
}

install_paru() {
  print_info "No AUR helper found, Installing paru."
  temp_dir=$(mktemp -d)

  git clone https://aur.archlinux.org/paru-bin.git "$temp_dir" &>/dev/null || {
    print_error "Failed to clone paru."
  }
  cd "$temp_dir" || return 1
  makepkg -si --noconfirm &>/dev/null || {
    print_error "Failed to build paru."
  }
  cd - >/dev/null || return 1
  rm -rf "$temp_dir"
}

install_package() {
  local packages=("$@")
  [[ ${#packages[@]} -eq 0 ]] && return 0

  # --- Detect AUR helper ---
  if has_package "paru" || has_package "paru-bin"; then
    AUR_HELPER="paru"
  elif has_package "yay" || has_package "yay-bin"; then
    AUR_HELPER="yay"
  else
    if install_paru; then
      AUR_HELPER="paru"
      print_info "paru installed successfully."
    else
      print_error "Failed to install paru. Please install it manually."
      return 1
    fi
  fi

  # --- Filter out already installed ---
  local to_install=()
  for pkg in "${packages[@]}"; do
    if has_package "$pkg"; then
      print_info "${STYLE_BOLD}${COLOR_CYAN}$pkg${COLOR_RESET} already installed."
    else
      to_install+=("$pkg")
    fi
  done

  [[ ${#to_install[@]} -eq 0 ]] && return 0

  local safe_install=()
  local conflict_install=()

  # --- Detect conflicts (with installed packages or Provides) ---
  for pkg in "${to_install[@]}"; do
    local info_cmd=(pacman -Si "$pkg")
    if ! pacman -Si "$pkg" &>/dev/null; then
      info_cmd=("$AUR_HELPER" -Si "$pkg")
    fi

    local has_conflict=0
    local conflicts=()
    while IFS= read -r conflict; do
      [[ -z $conflict ]] && continue
      conflicts+=("$conflict")
    done < <("${info_cmd[@]}" 2>/dev/null | awk -F': *' '/Conflicts With/ {print $2}' | tr -s ' ' '\n')

    # --- Check against installed packages & their provides ---
    for conflict in "${conflicts[@]}"; do
      if pacman -Qq "$conflict" &>/dev/null ||
        pacman -Qq --info | awk -F': *' '/Provides/ {print $2}' | grep -qw "$conflict"; then
        has_conflict=1
        break
      fi
    done

    # --- Check against other requested packages ---
    if [[ " ${to_install[*]} " == *" $conflict "* ]]; then
      has_conflict=1
    fi

    if ((has_conflict)); then
      conflict_install+=("$pkg")
    else
      safe_install+=("$pkg")
    fi
  done

  # --- Install safe packages (batch, no-confirm) ---
  if ((${#safe_install[@]})); then
    if ! "$AUR_HELPER" -S --needed --noconfirm "${safe_install[@]}"; then
      print_error "Some safe package installs failed: ${safe_install[*]}"
    fi
  fi

  # --- Install conflicting packages (interactive, one by one) ---
  if ((${#conflict_install[@]})); then
    print_step "Handling conflicting packages"
    print_warning "The following packages may conflict and require confirmation: ${conflict_install[*]}"
    for pkg in "${conflict_install[@]}"; do
      print_info "Installing $pkg interactively..."
      if ! "$AUR_HELPER" -S --needed "$pkg"; then
        print_error "Failed to install $pkg due to conflict resolution."
      fi
    done
  fi
}

initialize_env() {
  deps=(base-devel git gum figlet)
  missing_deps=()
  for dep in "${deps[@]}"; do
    if ! has_package "$dep"; then
      missing_deps+=("$dep")
    fi
  done

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_info "Syncing package database. This may take a while..."
    sudo pacman -Syu --noconfirm &>/dev/null || {
      print_error "Failed to sync package database."
    }
    print_info "Initializing environment, installing missing dependencies: ${missing_deps[*]}"
    sudo pacman -S --needed --noconfirm "${missing_deps[@]}" &>/dev/null || {
      print_error "Failed to install dependencies: ${missing_deps[*]}"
    }
  fi

}

# Common initialization function for all scripts
common_init() {
  # Check if running as root
  if [[ $EUID -eq 0 ]]; then
    print_error "This script should not be run as root. Please run it as a normal user."
  fi

  # Request sudo privileges
  ask_for_sudo

  # Initialize environment
  if initialize_env; then
    return 0
  else
    print_error "Failed to initialize environment."
  fi
}

# =============================================================================
# SERVICE MANAGEMENT
# =============================================================================
enable_service() {
  local service="$1"
  local scope="$2"
  local cmd=("systemctl")

  # Use sudo if scope is system, else add --user
  if [[ "$scope" == "user" ]]; then
    cmd+=("--user")
  else
    cmd=("sudo" "${cmd[@]}")
  fi
  if "${cmd[@]}" list-unit-files | grep -q "^${service}"; then

    if "${cmd[@]}" is-enabled "$service" &>/dev/null; then
      print_info "${COLOR_YELLOW}$service${COLOR_RESET} is already enabled."
    else
      if "${cmd[@]}" enable "$service" &>/dev/null; then
        print_info "${COLOR_MAGENTA}$service${COLOR_RESET} enabled successfully."
      else
        print_error "${COLOR_RED}$service${COLOR_RESET} failed to enable."
      fi
    fi

  else
    print_warning "Service not found: ${COLOR_YELLOW}$service${COLOR_RESET}"
  fi
}

reload_udev_rules() {
  if sudo udevadm control --reload-rules && sudo udevadm trigger; then
    return 0
  else
    return 1
  fi
}

reload_systemd_daemon() {
  if sudo systemctl daemon-reload; then
    return 0
  else
    return 1
  fi
}

is_laptop() {
  local chassis
  chassis=$(hostnamectl chassis)
  if [[ "$chassis" =~ (laptop|notebook) ]]; then
    return 0
  else
    return 1
  fi
}

# =============================================================================
# SNAPPER
# =============================================================================
set_snapper_config_value() {
  local config_name="$1"
  local key="$2"
  local value="$3"

  if ! sudo snapper list-configs | grep -q "^$config_name"; then
    if [ "$config_name" = "root" ]; then
      sudo snapper -c "$config_name" create-config /
    elif [ "$config_name" = "home" ]; then
      sudo snapper -c "$config_name" create-config /home
    else
      print_warning "Snapper config '$config_name' does not exist. Create it first."
      return 1
    fi
  fi

  if sudo snapper -c "$config_name" set-config "${key}=${value}"; then
    return 0
  else
    fail "Failed to set $key in snapper config '$config_name'"
  fi
}

# =============================================================================
# BOOTLOADER
# =============================================================================
_build_new_cmdline() {
  local current_cmdline="$1"
  local params_to_add="$2"

  # Use a map to store parameters. The key is the param name (e.g., "quiet"),
  # and the value is the full parameter (e.g., "amd_pstate=active").
  # This automatically handles overrides, as setting a key a second time
  # just updates its value.
  declare -A params_map

  for param in $current_cmdline $params_to_add; do
    params_map["${param%%=*}"]="$param"
  done

  echo "${params_map[*]}"
}

detect_bootloader() {
  if [[ -x /usr/bin/limine ]]; then
    echo "limine"
  elif [[ -f /etc/default/grub ]]; then
    echo "grub"
  else
    echo "unsupported"
  fi
}

update_grub_cmdline() {
  local params="$*"
  local grub_file="/etc/default/grub"

  print_info "Updating GRUB kernel command line..."

  local current_cmdline
  current_cmdline=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$grub_file" | sed 's/.*="\(.*\)"/\1/')

  local new_cmdline
  new_cmdline=$(_build_new_cmdline "$current_cmdline" "$params")

  if sudo sed -i "s|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT=\"$new_cmdline\"|" "$grub_file" &&
    sudo grub-mkconfig -o /boot/grub/grub.cfg &>/dev/null; then
    print_info "GRUB configuration updated successfully."
  else
    print_error "Failed to update GRUB."
  fi
}

update_limine_cmdline() {
  local dropin_name="$1"
  if [[ -z "$dropin_name" ]]; then
    print_error "update_limine_cmdline: drop-in filename is required (e.g., '50-hibernation.conf')"
  fi
  shift

  local params="$*"
  # Ensure .conf suffix for convenience
  [[ "$dropin_name" != *.conf ]] && dropin_name+=".conf"

  local dropin_dir="/etc/limine-entry-tool.d"

  if [[ ! -d "$dropin_dir" ]]; then
    if not has_package "limine-mkinitcpio-hook"; then
      print_info "Installing limine-mkinitcpio-hook for managing Limine drop-ins..."
      install_package "limine-mkinitcpio-hook" || {
        print_error "Failed to install limine-entry-tool. Cannot manage Limine drop-ins."

      }
    fi
  fi
  local dropin_file="$dropin_dir/$dropin_name"

  print_info "Writing Limine drop-in: $(basename "$dropin_file")"

  # Escape any double quotes in params to safely embed in quoted string
  local escaped
  escaped=$(printf '%s' "$params" | sed 's/"/\\"/g')

  if sudo mkdir -p "$dropin_dir" &&
    # must include += to append to existing KERNEL_CMDLINE else it will overwrite
    printf 'KERNEL_CMDLINE[default]+= "%s"\n' "$escaped" | sudo tee "$dropin_file" >/dev/null; then
    sudo chmod 0644 "$dropin_file" || true
  else
    print_error "Failed to write Limine drop-in: $dropin_file"
  fi
}

regenerate_initramfs() {
  if [[ $(detect_bootloader) == "grub" ]]; then
    print_info "Regenerating initramfs for GRUB..."
    if sudo mkinitcpio -P &>/dev/null; then
      print_info "Initramfs regenerated successfully."
    else
      print_error "Failed to regenerate initramfs."
    fi
  elif [[ $(detect_bootloader) == "limine" ]]; then
    print_info "Regenerating initramfs for Limine..."
    if sudo limine-mkinitcpio &>/dev/null; then
      print_info "Initramfs regenerated successfully."
    else
      print_error "Failed to regenerate initramfs."
    fi
  else
    print_warning "Unsupported bootloader, skipping initramfs regeneration."
  fi
}
# =============================================================================
# FILE SYSTEM
# =============================================================================
is_btrfs() {
  findmnt -n -o FSTYPE / | grep -q btrfs
}

get_btrfs_root_device() {
  device=$(findmnt -n -o SOURCE --target / 2>/dev/null)
  [[ -n "$device" ]] && echo "${device%%\[*}"
}

add_entry_to_fstab() {
  local entry="$1"
  local description="$2"

  if grep -qF "$entry" /etc/fstab; then
    print_info "Entry already exists in /etc/fstab: $description"
  else
    if echo -e "\n$entry\n" | sudo tee -a /etc/fstab >/dev/null; then
      print_info "Added entry $description to fstab"
      reload_systemd_daemon || print_warning "Failed to reload systemd daemon"
    else
      print_error "Failed to add $description to fstab"
    fi
  fi
}
