#!/usr/bin/env bash
# --- Color Variables ---

readonly COLOR_RED='\e[31m'
readonly COLOR_GREEN='\e[32m'
readonly COLOR_YELLOW='\e[33m'
readonly COLOR_MAGENTA='\e[35m'
readonly COLOR_CYAN='\e[36m'
readonly STYLE_BOLD='\e[1m'
readonly COLOR_RESET='\e[0m'

__HELPERS_DIR__="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __HELPERS_DIR__

#==============================================================================
# Logging Functions
#==============================================================================

print_step() {
  echo -e "\n${COLOR_MAGENTA}${STYLE_BOLD}==>${COLOR_RESET} ${COLOR_CYAN}$1${COLOR_RESET}\n"
}
print_info() {
  printf "${COLOR_GREEN}INFO:${COLOR_RESET} %b\n" "$1"
}
print_warning() {
  printf "${COLOR_YELLOW}WARNING:${COLOR_RESET} %b\n" "$1"
}
print_error() {
  printf "${COLOR_RED}ERROR:${COLOR_RESET} %b\n" "$1"
  exit 1
}
print_box() {
  figlet -t -f "$1" "$2"
}

confirm() {
  gum confirm --no-show-help --default=true "$1"
}

spinner() {
  local pid=$1
  local pkg="$2"

  gum spin --spinner line --title "Installing $pkg" -- sh -c "while kill -0 $pid 2>/dev/null; do sleep 0.1; done"
}

ask_for_sudo() {
  sudo -n true 2>/dev/null || {
    print_info "This script requires sudo privileges\n"
    sudo -v
  }
  while true; do
    sudo -n true
    sleep 60
    kill -0 "$$" || exit
  done 2>/dev/null &
}

# =============================================================================
# FILE MANIPULATION FUNCTIONS
# =============================================================================

write_system_config() {
  local config_file="$1"
  local description="$2"

  if sudo mkdir -p "$(dirname "$config_file")" && sudo tee "$config_file" >/dev/null; then
    sudo chmod 644 "$config_file" || print_error "Failed to set permissions for $config_file"
    print_info "$description written successfully"
  else
    print_error "Failed to write to $config_file"
  fi
}

create_backup() {
  local target_path="$1"
  local backup_path
  backup_path="${target_path}.bak.$(date +%Y%m%d%H%M%S)"

  if [ -e "$target_path" ]; then
    local backup_dir
    backup_dir=$(dirname "$backup_path")

    local copy_cmd=(cp)
    # Use sudo if destination dir is not writable
    if [ ! -w "$backup_dir" ]; then
      copy_cmd=(sudo cp)
    fi

    if [ -d "$target_path" ]; then
      if "${copy_cmd[@]}" -a "$target_path" "$backup_path"; then
        return 0
      else
        return 1
      fi
    else
      if "${copy_cmd[@]}" -a "$target_path" "$backup_path"; then
        return 0
      else
        return 1
      fi
    fi
  else
    print_warning "Path $target_path does not exist, skipping backup."
  fi
}

update_config() {
  local config_file="$1"
  local key="$2"
  local value="$3"

  if [[ ! -f "$config_file" ]]; then
    sudo touch "$config_file" &&
      if sudo chown root:root "$config_file"; then
        sudo chmod 644 "$config_file" || {
          print_error "Failed to create $config_file"
        }
      else
        print_error "Failed to set ownership for $config_file"
      fi
  fi

  local escaped_key
  escaped_key=$(printf '%s' "$key" | sed 's/\[/\\[/g; s/\]/\\]/g')
  # Regex to match lines like: [spaces][#][spaces]key[spaces]=
  local key_regex="^[[:space:]]*#*[[:space:]]*${escaped_key}[[:space:]]*="
  if sudo grep -qE "$key_regex" "$config_file"; then
    # Preserve existing spacing around '=' when updating
    # Capture spaces before and after '=' and reuse them in replacement
    if sudo sed -i -E "s|^[[:space:]]*#*[[:space:]]*${escaped_key}([[:space:]]*)=([[:space:]]*).*|${key}\\1=\\2${value}|" "$config_file"; then
      return 0
    else
      print_error "Failed to update $key in $config_file"
    fi
  else
    # Decide append style based on predominant style in file
    local style="compact"
    if sudo grep -qE '^[[:space:]]*[^#;][^=[:space:]]+[[:space:]]+=[[:space:]]+' "$config_file"; then
      style="spaced"
    fi

    if [[ "$style" == "spaced" ]]; then
      if echo -e "\n${key} = ${value}" | sudo tee -a "$config_file" >/dev/null; then
        return 0
      else
        print_error "Failed to append $key to $config_file"
      fi
    else
      if echo -e "\n${key}=${value}" | sudo tee -a "$config_file" >/dev/null; then
        return 0
      else
        print_error "Failed to append $key to $config_file"
      fi
    fi
  fi
}

# =============================================================================
# AUR HELPER INSTALLATION
# =============================================================================

has_package() {
  local pkg="$1"
  if pacman -Q "$pkg" &>/dev/null; then
    return 0
  else
    return 1
  fi
}

install_paru() {
  print_info "No AUR helper found, Installing paru."
  temp_dir=$(mktemp -d)

  git clone https://aur.archlinux.org/paru-bin.git "$temp_dir" &>/dev/null || {
    print_error "Failed to clone paru."
  }
  cd "$temp_dir" || return 1
  makepkg -si --noconfirm &>/dev/null || {
    print_error "Failed to build paru."
  }
  cd - >/dev/null || return 1
  rm -rf "$temp_dir"
}

build_install_sets() {
  INSTALL_SAFE=()
  INSTALL_CONFLICTED=()

  local input_pkgs=("$@")
  [[ ${#input_pkgs[@]} -eq 0 ]] && return 0

  # Build candidate list (skip already installed)
  local candidates=()
  local pkg
  for pkg in "${input_pkgs[@]}"; do
    if has_package "$pkg"; then
      print_info "$pkg ${COLOR_GREEN}Exists.${COLOR_RESET}"
    else
      candidates+=("$pkg")
    fi
  done

  [[ ${#candidates[@]} -eq 0 ]] && return 0

  local ck_output
  ck_output=$("${__HELPERS_DIR__}/.03_conflict-check" "${candidates[@]}" 2>/dev/null || true)

  # Extract query names that had conflicts
  declare -A __conflicted
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local q
    q=$(printf '%s' "$line" | awk '/ conflicts with / { split($0,a,/(^| )conflicts with /); if (a[2] !~ / /) print a[2] }')
    [[ -n "$q" ]] && __conflicted["$q"]=1
  done < <(printf '%s\n' "$ck_output")

  # Classify
  for pkg in "${candidates[@]}"; do
    if [[ -n ${__conflicted[$pkg]:-} ]]; then
      INSTALL_CONFLICTED+=("$pkg")
    else
      INSTALL_SAFE+=("$pkg")
    fi
  done
}

# Detect and set AUR_HELPER if not already set; installs paru if needed.
_ensure_aur_helper() {
  if [[ -n ${AUR_HELPER:-} ]]; then
    return 0
  fi

  for helper in paru yay; do
    if command -v "$helper" >/dev/null; then
      export AUR_HELPER=$helper
      return 0
    fi
  done

  install_paru
  AUR_HELPER=paru
}

install_package() {
  local req=("$@")
  [[ ${#req[@]} -eq 0 ]] && return 0
  _ensure_aur_helper
  build_install_sets "${req[@]}"

  # Install SAFE first (quiet path)
  if [[ ${#INSTALL_SAFE[@]} -gt 0 ]]; then
    "$AUR_HELPER" -S --needed --noconfirm "${INSTALL_SAFE[@]}"
  fi

  # Install CONFLICTED next (interactive)
  if [[ ${#INSTALL_CONFLICTED[@]} -gt 0 ]]; then
    print_step "Handling conflicted packages"
    print_info "Conflicted packages detected: ${INSTALL_CONFLICTED[*]}"
    print_info "Please review and confirm installation."
    "$AUR_HELPER" -S --needed "${INSTALL_CONFLICTED[@]}"
  fi
}

initialize_env() {
  deps=(base-devel git gum figlet)
  missing_deps=()
  for dep in "${deps[@]}"; do
    if ! has_package "$dep"; then
      missing_deps+=("$dep")
    fi
  done

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_info "Syncing package database. This may take a while..."
    sudo pacman -Syu --noconfirm &>/dev/null || {
      print_error "Failed to sync package database."
    }
    print_info "Initializing environment, installing missing dependencies: ${missing_deps[*]}"
    sudo pacman -S --needed --noconfirm "${missing_deps[@]}" &>/dev/null || {
      print_error "Failed to install dependencies: ${missing_deps[*]}"
    }
  fi

}

# Common initialization function for all scripts
common_init() {
  # Check if running as root
  if [[ $EUID -eq 0 ]]; then
    print_error "This script should not be run as root. Please run it as a normal user."
  fi

  # Request sudo privileges
  ask_for_sudo

  # Initialize environment
  if initialize_env; then
    return 0
  else
    print_error "Failed to initialize environment."
  fi
}

# =============================================================================
# SERVICE MANAGEMENT
# =============================================================================
enable_service() {
  local service="$1"
  local scope="$2"
  local cmd=("systemctl")

  # Use sudo if scope is system, else add --user
  if [[ "$scope" == "user" ]]; then
    cmd+=("--user")
  else
    cmd=("sudo" "${cmd[@]}")
  fi
  if "${cmd[@]}" list-unit-files | grep -q "^${service}"; then

    if "${cmd[@]}" is-enabled "$service" &>/dev/null; then
      print_info "${COLOR_YELLOW}$service${COLOR_RESET} is already enabled."
    else
      if "${cmd[@]}" enable "$service" &>/dev/null; then
        print_info "${COLOR_MAGENTA}$service${COLOR_RESET} enabled successfully."
      else
        print_error "${COLOR_RED}$service${COLOR_RESET} failed to enable."
      fi
    fi

  else
    print_warning "Service not found: ${COLOR_YELLOW}$service${COLOR_RESET}"
  fi
}

reload_udev_rules() {
  if sudo udevadm control --reload-rules && sudo udevadm trigger; then
    return 0
  else
    return 1
  fi
}

reload_systemd_daemon() {
  if sudo systemctl daemon-reload; then
    return 0
  else
    return 1
  fi
}

is_laptop() {
  local chassis
  chassis=$(hostnamectl chassis)
  if [[ "$chassis" =~ (laptop|notebook) ]]; then
    return 0
  else
    return 1
  fi
}

# =============================================================================
# SNAPPER
# =============================================================================
set_snapper_config_value() {
  local config_name="$1"
  local key="$2"
  local value="$3"

  if ! sudo snapper list-configs | grep -q "^$config_name"; then
    if [ "$config_name" = "root" ]; then
      sudo snapper -c "$config_name" create-config /
    elif [ "$config_name" = "home" ]; then
      sudo snapper -c "$config_name" create-config /home
    else
      print_warning "Snapper config '$config_name' does not exist. Create it first."
      return 1
    fi
  fi

  if sudo snapper -c "$config_name" set-config "${key}=${value}"; then
    return 0
  else
    fail "Failed to set $key in snapper config '$config_name'"
  fi
}

# =============================================================================
# BOOTLOADER
# =============================================================================
_build_new_cmdline() {
  local current_cmdline="$1"
  local params_to_add="$2"

  # Use a map to store parameters. The key is the param name (e.g., "quiet"),
  # and the value is the full parameter (e.g., "amd_pstate=active").
  # This automatically handles overrides, as setting a key a second time
  # just updates its value.
  declare -A params_map

  for param in $current_cmdline $params_to_add; do
    params_map["${param%%=*}"]="$param"
  done

  echo "${params_map[*]}"
}

detect_bootloader() {
  if [[ -x /usr/bin/limine ]]; then
    echo "limine"
  elif [[ -f /etc/default/grub ]]; then
    echo "grub"
  else
    echo "unsupported"
  fi
}

update_grub_cmdline() {
  local params="$*"
  local grub_file="/etc/default/grub"

  print_info "Updating GRUB kernel command line..."

  local current_cmdline
  current_cmdline=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$grub_file" | sed 's/.*="\(.*\)"/\1/')

  local new_cmdline
  new_cmdline=$(_build_new_cmdline "$current_cmdline" "$params")

  if sudo sed -i "s|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT=\"$new_cmdline\"|" "$grub_file" &&
    sudo grub-mkconfig -o /boot/grub/grub.cfg &>/dev/null; then
    print_info "GRUB configuration updated successfully."
  else
    print_error "Failed to update GRUB."
  fi
}

update_limine_cmdline() {
  local dropin_name="$1"
  if [[ -z "$dropin_name" ]]; then
    print_error "update_limine_cmdline: drop-in filename is required (e.g., '50-hibernation.conf')"
  fi
  shift

  local params="$*"
  # Ensure .conf suffix for convenience
  [[ "$dropin_name" != *.conf ]] && dropin_name+=".conf"

  local dropin_dir="/etc/limine-entry-tool.d"

  if [[ ! -d "$dropin_dir" ]]; then
    if not has_package "limine-mkinitcpio-hook"; then
      print_info "Installing limine-mkinitcpio-hook for managing Limine drop-ins..."
      install_package "limine-mkinitcpio-hook" || {
        print_error "Failed to install limine-entry-tool. Cannot manage Limine drop-ins."

      }
    fi
  fi
  local dropin_file="$dropin_dir/$dropin_name"

  print_info "Writing Limine drop-in: $(basename "$dropin_file")"

  # Escape any double quotes in params to safely embed in quoted string
  local escaped
  escaped=$(printf '%s' "$params" | sed 's/"/\\"/g')

  if sudo mkdir -p "$dropin_dir" &&
    # must include += to append to existing KERNEL_CMDLINE else it will overwrite
    printf 'KERNEL_CMDLINE[default]+= "%s"\n' "$escaped" | sudo tee "$dropin_file" >/dev/null; then
    sudo chmod 0644 "$dropin_file" || true
  else
    print_error "Failed to write Limine drop-in: $dropin_file"
  fi
}

regenerate_initramfs() {
  if [[ $(detect_bootloader) == "grub" ]]; then
    print_info "Regenerating initramfs for GRUB..."
    if sudo mkinitcpio -P &>/dev/null; then
      print_info "Initramfs regenerated successfully."
    else
      print_error "Failed to regenerate initramfs."
    fi
  elif [[ $(detect_bootloader) == "limine" ]]; then
    print_info "Regenerating initramfs for Limine..."
    if sudo limine-mkinitcpio &>/dev/null; then
      print_info "Initramfs regenerated successfully."
    else
      print_error "Failed to regenerate initramfs."
    fi
  else
    print_warning "Unsupported bootloader, skipping initramfs regeneration."
  fi
}
# =============================================================================
# FILE SYSTEM
# =============================================================================
is_btrfs() {
  findmnt -n -o FSTYPE / | grep -q btrfs
}

get_btrfs_root_device() {
  device=$(findmnt -n -o SOURCE --target / 2>/dev/null)
  [[ -n "$device" ]] && echo "${device%%\[*}"
}

add_entry_to_fstab() {
  local entry="$1"
  local description="$2"

  if grep -qF "$entry" /etc/fstab; then
    print_info "Entry already exists in /etc/fstab: $description"
  else
    if echo -e "\n$entry\n" | sudo tee -a /etc/fstab >/dev/null; then
      print_info "Added entry $description to fstab"
      reload_systemd_daemon || print_warning "Failed to reload systemd daemon"
    else
      print_error "Failed to add $description to fstab"
    fi
  fi
}
