#!/bin/bash

set -o errexit -o nounset -o pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <package> [<package> ...]" >&2
  exit 2
fi

queries=("$@")

# Build alias list for the queries: names themselves + any Provides from repo/local
aliases=("${queries[@]}")

# Detect AUR helper (optional, for AUR package metadata)
AUR_HELPER=${AUR_HELPER:-}

# Collect metadata for all query packages once (repo via pacman; AUR via helper if available)
tmp_qmeta=$(mktemp)
trap 'rm -f "$tmp_qmeta"' EXIT
{
  printf '%s\n' "${queries[@]}" | xargs -r -n100 pacman -Si -- 2>/dev/null || true
  printf '%s\n' "${queries[@]}" | xargs -r -n100 pacman -Qi -- 2>/dev/null || true
  if [[ -n "$AUR_HELPER" ]]; then
    printf '%s\n' "${queries[@]}" | xargs -r -n100 "$AUR_HELPER" -Si -- 2>/dev/null || true
  fi
} >"$tmp_qmeta" || true

# Extract provided aliases and append to aliases array
while IFS= read -r prov; do
  [[ -n "$prov" ]] && aliases+=("$prov")
done < <(
  awk '
    BEGIN { RS=""; FS="\n" }
    {
      for (i=1; i<=NF; i++) {
        line=$i
        if (line ~ /^Provides[[:space:]]*:/) {
          sub(/^Provides[[:space:]]*:[[:space:]]*/, "", line)
          j=i+1
          while (j<=NF && $j ~ /^[[:space:]]+/) { seg=$j; sub(/^[[:space:]]+/, "", seg); line = line " " seg; j++ }
          n=split(line, a, /[[:space:]]+/)
          for (k=1; k<=n; k++) { prov=a[k]; sub(/([<>=].*)$/, "", prov); if (prov != "" && prov != "None") print prov }
        }
      }
    }
  ' "$tmp_qmeta"
)

# Forward check (fast): installed packages whose CONFLICTS include any alias (parse local pacman DB)
forward_output=$(awk -v toks="${aliases[*]}" '
  function stripver(s){ sub(/([<>=].*)$/, "", s); return s }
  BEGIN { split(toks, T, /[[:space:]]+/); for (i=1;i<=length(T);i++) if (T[i] != "") TOK[T[i]]=1 }
  FNR==1 { name=""; conflicts=""; inconf=0 }
  $0=="%NAME%" { getline; name=$0; inconf=0; next }
  $0=="%CONFLICTS%" { inconf=1; next }
  /^%/ { inconf=0; next }
  inconf && $0!="" { if (conflicts) conflicts=conflicts " " $0; else conflicts=$0 }
  ENDFILE {
    if (conflicts!="" && conflicts!="None" && name!="") {
      n=split(conflicts, C, /[[:space:]]+/)
      hit=0
      for (k=1;k<=n;k++){ t=stripver(C[k]); if (t in TOK){ hit=1; break } }
      if (hit){ gsub(/[[:space:]]+/, " ", conflicts); sub(/^[[:space:]]+/, "", conflicts); sub(/[[:space:]]+$/, "", conflicts); print name " conflicts with " conflicts }
    }
    name=""; conflicts=""; inconf=0
  }
' /var/lib/pacman/local/*/desc 2>/dev/null || true)

# Collect reverse hits here
declare -a reverse_hits=()

# Build installed set once
mapfile -t installed_pkgs < <(pacman -Qq)
declare -A installed_map
for p in "${installed_pkgs[@]}"; do installed_map["$p"]=1; done

# Reverse check: all query packages' conflicts against installed names
while IFS= read -r line; do
  qname=${line%%::*}
  conflicts_str=${line#*::}
  for token in $conflicts_str; do
    token=${token%%[<>=]*}
    if [[ -n "${installed_map[$token]:-}" ]]; then
      reverse_hits+=("$token conflicts with $qname")
    fi
  done
done < <(
  awk '
    BEGIN { RS=""; FS="\n" }
    {
      qname=""; conflicts=""
      for (i=1; i<=NF; i++) {
        line=$i
        if (line ~ /^Name[[:space:]]*:/) { sub(/^Name[[:space:]]*:[[:space:]]*/, "", line); qname=line }
        else if (line ~ /^Conflicts( With)?[[:space:]]*:/) {
          sub(/^Conflicts( With)?[[:space:]]*:[[:space:]]*/, "", line)
          j=i+1
          while (j<=NF && $j ~ /^[[:space:]]+/) { seg=$j; sub(/^[[:space:]]+/, "", seg); line = line " " seg; j++ }
          conflicts=line
        }
      }
      if (conflicts == "" || conflicts == "None") next
      gsub(/[[:space:]]+/, " ", conflicts); gsub(/^[[:space:]]+|[[:space:]]+$/, "", conflicts)
      print qname "::" conflicts
    }
  ' "$tmp_qmeta"
)

{
  [[ -n "$forward_output" ]] && printf "%s\n" "$forward_output"
  if ((${#reverse_hits[@]})); then printf "%s\n" "${reverse_hits[@]}"; fi
} | sort -u
